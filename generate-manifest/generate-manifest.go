package main

import (
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"github.com/joho/godotenv"
)

type ProdManifestEntry struct {
	File    string   `json:"file"`
	Name    string   `json:"name"`
	Src     string   `json:"src"`
	IsEntry bool     `json:"isEntry"`
	Imports []string `json:"imports"`
}

type DevManifest struct {
	URL    string            `json:"url"`
	Inputs map[string]string `json:"inputs"`
}

func main() {

	// Get the project root (assuming script is run from root or adjust based on context)
	rootDir, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get working directory: %v", err)
	}

	var manifestPath string
	if isInDev() {
		manifestPath = filepath.Join(rootDir, "gen", "manifest.dev.json")
	} else {
		manifestPath = filepath.Join(rootDir, "gen", ".vite", "manifest.json")
	}

	// Read manifest.json
	file, err := os.ReadFile(manifestPath)
	if err != nil {
		log.Fatalf("Failed to read manifest: %v", err)
	}

	// Parse based on environment
	var cache map[string]string
	if isInDev() {
		var devManifest DevManifest
		if err := json.Unmarshal(file, &devManifest); err != nil {
			log.Fatalf("Failed to parse dev manifest: %v", err)
		}
		cache = make(map[string]string)
		for inputName, srcPath := range devManifest.Inputs {
			// Map input name (e.g., "goooNavigation") to served URL
			servedPath := inputName // Use the input name directly
			hashedPath := srcPath   // e.g., "http://localhost:5173/utils/goooNavigation.ts"
			cache[servedPath] = hashedPath
		}
	} else {
		var prodManifest map[string]ProdManifestEntry
		if err := json.Unmarshal(file, &prodManifest); err != nil {
			log.Fatalf("Failed to parse prod manifest: %v", err)
		}
		cache = make(map[string]string)
		for _, entry := range prodManifest {
			if entry.IsEntry {
				servedPath := entry.Name
				hashedPath := "/gen/" + entry.File
				cache[servedPath] = hashedPath
			}
		}
	}

	// Template for the generated Go file
	const tmpl = `// Code generated by generate_manifest.go; DO NOT EDIT.
package serverGenerated

// ManifestCache is the pre-generated manifest cache
var ManifestCache = map[string]string{
{{range $key, $value := .}}
	"{{$key}}": "{{$value}}",
{{end}}
}
`

	t, err := template.New("manifest").Parse(tmpl)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	// Ensure the serverGenerated directory exists
	outputDir := filepath.Join(rootDir, "server", "generated")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("Failed to create directory %s: %v", outputDir, err)
	}

	// Write the generated file
	outputPath := filepath.Join(outputDir, "generated-manifest.go")
	f, err := os.Create(outputPath)
	if err != nil {
		log.Fatalf("Failed to create generated file %s: %v", outputPath, err)
	}
	defer f.Close()

	if err := t.Execute(f, cache); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	log.SetFlags(0)
	log.Println("\u2022 Generated manifest cache successfully")
}

func isInDev() bool {
	envFile := os.Getenv("ENV_FILE")
	if err := godotenv.Load(envFile); err != nil {
		log.Printf("WARNING: Couldn't load %s file: %v", envFile, err)
	}

	return os.Getenv("ENV") == "DEV"
}
